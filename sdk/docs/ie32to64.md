# IE32-to-IE64 Assembly Converter

Source-to-source transpiler that converts IE32 assembly (`.asm`) files into valid IE64 assembly that can be assembled with `ie64asm`.

## Quick Start

```bash
# Build
go build -o bin/ie32to64 ./cmd/ie32to64/

# Convert a file
bin/ie32to64 sdk/examples/asm/rotozoomer.asm
# → produces sdk/examples/asm/rotozoomer_ie64.asm

# Convert with explicit output path
bin/ie32to64 -o output.asm sdk/examples/asm/rotozoomer.asm

# Upgrade to 64-bit operations
bin/ie32to64 -size .q sdk/examples/asm/program.asm

# Print conversion statistics
bin/ie32to64 -stats sdk/examples/asm/rotozoomer.asm
```

## CLI Reference

```
Usage: ie32to64 [options] input.asm

Options:
  -o output.asm    Output file (default: input_ie64.asm)
  -size .l|.q      Default size suffix (default: .l, use .q for 64-bit)
  -no-header       Omit "Converted from IE32" header comment
  -stats           Print conversion statistics
  -h               Help
```

## Register Mapping

IE32's 16 named registers map to IE64 r1-r16. Registers r0 (hardwired zero), r17-r20 (converter scratch), and r21-r31 (free/SP) are available for hand-optimization after conversion.

| IE32 | IE64 | IE32 | IE64 |
|------|------|------|------|
| A    | r1   | F    | r9   |
| X    | r2   | G    | r10  |
| Y    | r3   | H    | r11  |
| Z    | r4   | S    | r12  |
| B    | r5   | T    | r13  |
| C    | r6   | U    | r14  |
| D    | r7   | V    | r15  |
| E    | r8   | W    | r16  |

**Scratch registers**: r17 is the primary scratch register for address loads (`la r17, addr`). r18-r20 are used for multi-step expansions like `INC @addr`.

## Instruction Reference

### Zero-Operand Instructions

| IE32 | IE64 |
|------|------|
| `NOP` | `nop` |
| `HALT` | `halt` |
| `RTS` | `rts` |
| `SEI` | `sei` |
| `CLI` | `cli` |
| `RTI` | `rti` |

### Load Instructions

Register-specific loads (`LDA`, `LDB`, ..., `LDW`) and generic `LOAD`:

| IE32 | IE64 | Notes |
|------|------|-------|
| `LDA #42` | `move.l r1, #42` | Immediate |
| `LDA @0x5000` | `la r17, 0x5000` + `load.l r1, (r17)` | Memory dereference |
| `LDA 0x5000` | `move.l r1, #0x5000` | Bare number = immediate! |
| `LDA MY_CONST` | `move.l r1, #MY_CONST` | Bare equate = immediate |
| `LDA [B]` | `load.l r1, (r5)` | Register-indirect |
| `LDA [B+8]` | `load.l r1, 8(r5)` | Register+offset |
| `LDA X` | `move.l r1, r2` | Register-to-register |
| `LOAD A, #42` | `move.l r1, #42` | Generic load, immediate |
| `LOAD A, X` | `move.l r1, r2` | Generic load, register |
| `LOAD A, @0x5000` | `la r17, 0x5000` + `load.l r1, (r17)` | Generic load, dereference |

### Store Instructions

Register-specific stores (`STA`, `STB`, ..., `STW`) and generic `STORE`:

| IE32 | IE64 | Notes |
|------|------|-------|
| `STA @0x5000` | `la r17, 0x5000` + `store.l r1, (r17)` | Memory write via @ |
| `STA 0x5000` | `la r17, 0x5000` + `store.l r1, (r17)` | Bare addr = memory write |
| `STA [B]` | `store.l r1, (r5)` | Register-indirect |
| `STORE A, @0x5000` | `la r17, 0x5000` + `store.l r1, (r17)` | Generic store |
| `STORE A, [B]` | `store.l r1, (r5)` | Generic store, indirect |

**Key semantic rule**: In IE32, `LOAD A, 0x5000` loads the *value* 0x5000 into A (immediate), but `STORE A, 0x5000` writes A *to memory address* 0x5000. The `@` prefix explicitly marks memory dereference for LOAD.

### ALU Instructions (2-operand → 3-operand)

IE32's `OP reg, operand` becomes IE64's `op.l reg, reg, operand`:

| IE32 | IE64 |
|------|------|
| `ADD A, #10` | `add.l r1, r1, #10` |
| `ADD A, X` | `add.l r1, r1, r2` |
| `SUB A, #5` | `sub.l r1, r1, #5` |
| `MUL A, #3` | `mulu.l r1, r1, #3` |
| `DIV A, #2` | `divu.l r1, r1, #2` |
| `MOD A, #7` | `mod.l r1, r1, #7` |
| `AND A, #0xFF` | `and.l r1, r1, #0xFF` |
| `OR A, #0x80` | `or.l r1, r1, #0x80` |
| `XOR A, #0xFF` | `eor.l r1, r1, #0xFF` |
| `SHL A, #4` | `lsl.l r1, r1, #4` |
| `SHR A, #4` | `lsr.l r1, r1, #4` |
| `NOT A` | `not.l r1, r1` |

ALU with memory operands expand to multi-line sequences:

```asm
; IE32: ADD A, @addr
la r17, addr
load.l r17, (r17)
add.l r1, r1, r17

; IE32: ADD A, [B]
load.l r17, (r5)
add.l r1, r1, r17

; IE32: ADD A, [B+8]
load.l r17, 8(r5)
add.l r1, r1, r17
```

### INC/DEC

| IE32 | IE64 |
|------|------|
| `INC A` | `add.l r1, r1, #1` |
| `DEC A` | `sub.l r1, r1, #1` |

Memory INC/DEC expand to 4-line read-modify-write:

```asm
; IE32: INC @0x5000
la r17, 0x5000
load.l r18, (r17)
add.l r18, r18, #1
store.l r18, (r17)
```

### Jump/Branch Instructions

| IE32 | IE64 | Notes |
|------|------|-------|
| `JMP label` | `bra label` | Unconditional |
| `JSR label` | `jsr label` | Subroutine call |
| `JNZ A, label` | `bnez r1, label` | Branch if not zero |
| `JZ A, label` | `beqz r1, label` | Branch if zero |
| `JGT A, label` | `bgtz r1, label` | Branch if greater than zero |
| `JGE A, label` | `bgez r1, label` | Branch if greater or equal zero |
| `JLT A, label` | `bltz r1, label` | Branch if less than zero |
| `JLE A, label` | `blez r1, label` | Branch if less or equal zero |

### Stack Instructions

| IE32 | IE64 |
|------|------|
| `PUSH A` | `push r1` |
| `POP A` | `pop r1` |

### WAIT

| IE32 | IE64 | Notes |
|------|------|-------|
| `WAIT #100` | `wait #100` | Immediate passthrough |
| `WAIT #DELAY_US` | `wait #DELAY_US` | Equate with # |
| `WAIT DELAY_US` | `wait #DELAY_US` | Bare equate → prepend # |
| `WAIT 0x1000` | `wait #0x1000` | Bare hex → prepend # |
| `WAIT A` | **ERROR** | Register operand not supported |
| `WAIT @0x5000` | **ERROR** | Memory dereference not supported |

## Directive Reference

| IE32 | IE64 |
|------|------|
| `.org 0x1000` | `org 0x1000` |
| `.equ NAME 0x1234` | `NAME equ 0x1234` |
| `.equ NAME BASE+8` | `NAME equ BASE+8` |
| `.word v1, v2` | `dc.l v1, v2` |
| `.byte v1, v2` | `dc.b v1, v2` |
| `.space 256` | `ds.b 256` |
| `.ascii "hello"` | `dc.b "hello"` |
| `.incbin "file"` | `incbin "file"` |
| `.incbin "f", off, len` | `incbin "f", off, len` |
| `.include "file"` | `include "file"` (auto-rewrites `ie32.inc` → `ie64.inc`) |

Note: `.word` in IE32 emits 32-bit values (unlike conventional assemblers), so it maps to `dc.l` (not `dc.w`).

## Operand Semantics

Understanding IE32's operand resolution is critical for correct conversion:

| Prefix | Type | Meaning |
|--------|------|---------|
| `#` | Immediate | Literal value |
| `@` | Direct | Memory dereference at address |
| `[R]` | Register-indirect | Memory at address in register |
| `[R+N]` | Register+offset | Memory at register + N |
| *(none)* | Bare | Context-dependent (see below) |

**Bare operands** (no prefix):
- In `LOAD`: bare values are **immediate** - `LOAD A, 0x5000` puts 0x5000 into A
- In `STORE`: bare values are **memory addresses** - `STORE A, 0x5000` writes A to address 0x5000
- In ALU ops: bare values are **immediate** - `ADD A, MY_CONST` adds the constant value
- Bare register names are recognized as registers: `LOAD A, X` copies X into A

## Known Limitations

1. **No `.include` expansion** - the converter processes files line-by-line without
   expanding includes. It auto-rewrites `ie32.inc` → `ie64.inc` (the IE64 equivalent
   with identical hardware constants). Other include files must be converted separately.

2. **No semantic analysis** - line-by-line conversion without register liveness tracking.
   Scratch registers r17-r18 are reloaded before each use within every multi-line
   expansion, so consecutive expansions are safe. However, if you interleave hand-written
   IE64 code that uses r17-r18 with converted code, verify no conflicts.

3. **Expressions pass through unchanged** - `RING_BASE + 1` is emitted as-is, which
   is correct since IE64 supports the same `+`/`-` expression operators.

4. **Unknown mnemonics produce hard errors** - typos and non-standard syntax
   (like `coproc_service_ie32.asm`'s lowercase `move`) cause errors. Fix the
   source to valid IE32 before converting.

## Post-Conversion Checklist

After running the converter:

1. **Review multi-line expansions** - search for `r17` to find expansion points; verify scratch register usage doesn't conflict with surrounding code
2. **Check for `; ERROR:`** - search the output for error markers; fix source and reconvert
3. **Test assembly** - run `ie64asm` on the output to verify it assembles cleanly
4. **Consider optimization** - IE64's 3-operand format and r0 (zero register) enable optimizations the converter doesn't perform (e.g., `move.l r1, r0` instead of `move.l r1, #0`)

## Example: Before and After

### IE32 (rotozoomer excerpt)

```asm
.include "ie32.inc"
.equ TEXTURE_BASE 0x500000
.org 0x1000

start:
    LDA #1
    STA @VIDEO_CTRL
    LDA #0
    STA @VIDEO_MODE
    JSR generate_texture
    LDA #0
    STA @VAR_ANGLE_ACC
    STA @VAR_SCALE_ACC
    JMP main_loop

wait_vsync:
wait_end:
    LDA @VIDEO_STATUS
    AND A, #STATUS_VBLANK
    JNZ A, wait_end
wait_start:
    LDA @VIDEO_STATUS
    AND A, #STATUS_VBLANK
    JZ A, wait_start
    RTS
```

### IE64 (converted output)

```asm
; Converted from IE32 by ie32to64

include "ie64.inc"
TEXTURE_BASE equ 0x500000
org 0x1000

start:
    move.l r1, #1
    la r17, VIDEO_CTRL
    store.l r1, (r17)
    move.l r1, #0
    la r17, VIDEO_MODE
    store.l r1, (r17)
    jsr generate_texture
    move.l r1, #0
    la r17, VAR_ANGLE_ACC
    store.l r1, (r17)
    la r17, VAR_SCALE_ACC
    store.l r1, (r17)
    bra main_loop

wait_vsync:
wait_end:
    la r17, VIDEO_STATUS
    load.l r1, (r17)
    and.l r1, r1, #STATUS_VBLANK
    bnez r1, wait_end
wait_start:
    la r17, VIDEO_STATUS
    load.l r1, (r17)
    and.l r1, r1, #STATUS_VBLANK
    beqz r1, wait_start
    rts
```
