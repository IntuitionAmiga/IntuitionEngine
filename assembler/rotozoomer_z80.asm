; rotozoomer_z80.asm - Z80 bit-exact rotozoomer (benchmark)
;
; Z80 port of IE32/M68020 rotozoomer with identical math/output.
; Uses precomputed tables and texture generated by tools/gen_rotozoomer_tables.go
;
; Assemble: vasmz80_std -Fbin -I. -o assembler/rotozoomer_z80.ie80 assembler/rotozoomer_z80.asm
; Run:      ./bin/IntuitionEngine -z80 assembler/rotozoomer_z80.ie80

    .include "ie80.inc"

; =============================================================================
; CONSTANTS
; =============================================================================

.set RENDER_W,640
.set RENDER_H,480
.set LINE_BYTES,2560

.set BACK_BUFFER,0x22C000
.set VRAM_START,0x100000

.set TABLES_BASE,0xE000
.set TEXTURE_BASE,0x14000
.set TABLES_BANK_BASE,0x07     ; TABLES_BASE / 0x2000
.set TEXTURE_BANK_BASE,0x0A    ; TEXTURE_BASE / 0x2000

; Table offsets (bank 0)
.set OFF_SINE,0x0000
.set OFF_RECIP,0x0400
.set OFF_SCALE_SEL,0x0420
.set OFF_TEX_BANK,0x0520
.set OFF_TEX_ROW,0x0620
.set OFF_SCALE0,0x1000

; Scale block offsets (4KB)
.set OFF_DU,0x0000
.set OFF_DV,0x0400
.set OFF_ROW_U,0x0800
.set OFF_ROW_V,0x0C00

; =============================================================================
; VARIABLES (RAM)
; =============================================================================
.set VAR_BASE,0xC000
.set var_angle,VAR_BASE+0
.set var_scale_idx,VAR_BASE+1
.set var_scale_sel,VAR_BASE+2
.set var_pad0,VAR_BASE+3
.set var_du_dx,VAR_BASE+4
.set var_dv_dx,VAR_BASE+8
.set var_du_dy,VAR_BASE+12
.set var_dv_dy,VAR_BASE+16
.set var_row_u,VAR_BASE+20
.set var_row_v,VAR_BASE+24
.set var_u,VAR_BASE+28
.set var_v,VAR_BASE+32
.set var_scale_bank,VAR_BASE+36
.set var_scale_off,VAR_BASE+37     ; 2 bytes
.set var_curr_tex_bank,VAR_BASE+39
.set var_row_count,VAR_BASE+40     ; 2 bytes
.set var_y_bank_ptr,VAR_BASE+42    ; 2 bytes
.set var_temp_base,VAR_BASE+44     ; 2 bytes
.set var_temp_offset,VAR_BASE+46   ; 2 bytes

.set y_bank,VAR_BASE+64            ; 480 bytes
.set y_off,VAR_BASE+544            ; 480 * 2 bytes = 960 bytes

; =============================================================================
; ENTRY POINT
; =============================================================================
    .org 0x0000

start:
    di
    ld sp,0xE000

    call init_video
    call init_y_addr

    xor a
    ld (var_angle),a
    ld a,192
    ld (var_scale_idx),a

main_loop:
    call update_animation
    WAIT_VBLANK
    call render_mode7
    jp main_loop

; =============================================================================
; VIDEO INIT
; =============================================================================
init_video:
    xor a
    ld (VIDEO_MODE),a
    ld (VIDEO_MODE+1),a
    ld (VIDEO_MODE+2),a
    ld (VIDEO_MODE+3),a
    ld a,1
    ld (VIDEO_CTRL),a
    ret

; =============================================================================
; INIT Y ADDRESS TABLE (back buffer)
; =============================================================================
init_y_addr:
    ld hl,0x0000                   ; offset within VRAM bank
    ld a,0x8B                       ; BACK_BUFFER / 0x4000
    ld iy,y_off
    ld ix,y_bank
    ld bc,RENDER_H

.row_loop_init:
    ld (ix+0),a                     ; bank
    ld (iy+0),l                     ; offset low
    ld (iy+1),h                     ; offset high
    inc iy
    inc iy
    inc ix

    ld de,LINE_BYTES
    add hl,de
    ld d,a                          ; preserve bank in D
    ld a,h
    bit 6,a                         ; test if HL >= 0x4000
    jr z,.no_wrap
    sub 0x40                        ; H -= 0x40 (HL -= 0x4000)
    ld h,a
    inc d                           ; bank++
.no_wrap:
    ld a,d                          ; restore bank to A

    dec bc
    push af                         ; save bank value
    ld a,b
    or c
    jr z,.init_done
    pop af                          ; restore bank for next iteration
    jr .row_loop_init
.init_done:
    pop af                          ; clean up stack
    ret

; =============================================================================
; UPDATE ANIMATION (bit-exact)
; =============================================================================
update_animation:
    ld a,(var_angle)
    inc a
    ld (var_angle),a

    ld a,(var_scale_idx)
    add a,2
    ld (var_scale_idx),a

    ; scale_sel = scale_sel_table[scale_idx]
    SET_BANK3 TABLES_BANK_BASE
    ld a,(var_scale_idx)
    ld l,a
    ld h,0
    ld de,BANK3_WINDOW+OFF_SCALE_SEL
    add hl,de
    ld a,(hl)
    ld (var_scale_sel),a

    ; Select scale bank/offset
    ld a,(var_scale_sel)
    ld e,a
    ld d,0
    ld hl,scale_bank_table
    add hl,de
    ld a,(hl)
    ld (var_scale_bank),a

    ld a,(var_scale_sel)
    add a,a
    ld e,a
    ld d,0
    ld hl,scale_off_table
    add hl,de
    ld a,(hl)
    ld (var_scale_off),a
    inc hl
    ld a,(hl)
    ld (var_scale_off+1),a

    ; Load DU/DV/RowU/RowV from scale bank
    ld a,(var_scale_bank)
    ld (BANK3_REG_LO),a
    xor a
    ld (BANK3_REG_HI),a

    ld a,(var_angle)
    ld l,a
    ld h,0
    add hl,hl
    add hl,hl                       ; angle * 4
    ld (var_temp_offset),hl

    ld hl,BANK3_WINDOW
    ld de,(var_scale_off)
    add hl,de
    ld (var_temp_base),hl

    ld hl,(var_temp_base)
    ld de,(var_temp_offset)
    add hl,de
    ld de,var_du_dx
    call load32

    ld hl,(var_temp_base)
    ld de,(var_temp_offset)
    add hl,de
    ld de,OFF_DV
    add hl,de
    ld de,var_dv_dx
    call load32

    ld hl,(var_temp_base)
    ld de,(var_temp_offset)
    add hl,de
    ld de,OFF_ROW_U
    add hl,de
    ld de,var_row_u
    call load32

    ld hl,(var_temp_base)
    ld de,(var_temp_offset)
    add hl,de
    ld de,OFF_ROW_V
    add hl,de
    ld de,var_row_v
    call load32

    ; du_dy = -dv_dx
    ld hl,var_dv_dx
    ld de,var_du_dy
    call neg32

    ; dv_dy = du_dx
    ld hl,var_du_dx
    ld de,var_dv_dy
    call copy32

    ret

; =============================================================================
; PIXEL MACRO (unrolled inner loop)
; =============================================================================
.macro PIXEL
    ; texY = (v >> 8) & 0xFF (byte 1)
    ld a,(var_v+1)
    ld l,a
    ld h,0
    ld de,BANK3_WINDOW+OFF_TEX_BANK
    add hl,de
    ld a,(hl)
    ld d,a                          ; tex bank in D

    ld a,(var_curr_tex_bank)
    cp d
    jr z,.bank_ok\@
    ld a,d
    ld (var_curr_tex_bank),a
    ld (BANK1_REG_LO),a
    xor a
    ld (BANK1_REG_HI),a
.bank_ok\@:
    ld a,(var_v+1)
    ld l,a
    ld h,0
    add hl,hl                       ; texY * 2 (TEX_ROW is uint16 array)
    ld de,BANK3_WINDOW+OFF_TEX_ROW
    add hl,de
    ld a,(hl)
    ld e,a
    inc hl
    ld a,(hl)
    ld d,a                          ; DE = row offset

    ld a,(var_u+1)
    ld l,a
    ld h,0
    add hl,hl
    add hl,hl                       ; HL = texX * 4
    add hl,de
    ld de,BANK1_WINDOW
    add hl,de

    ld a,(hl)
    ld (ix+0),a
    inc hl
    ld a,(hl)
    ld (ix+1),a
    inc hl
    ld a,(hl)
    ld (ix+2),a
    inc hl
    ld a,(hl)
    ld (ix+3),a

    ld de,4
    add ix,de

    ld hl,var_u
    ld de,var_du_dx
    call add32

    ld hl,var_v
    ld de,var_dv_dx
    call add32
.endm

; =============================================================================
; RENDER
; =============================================================================
render_mode7:
    ; Configure Mode7 blit directly to front VRAM.
    STORE32 BLT_OP, BLT_OP_MODE7
    STORE32 BLT_SRC_0, TEXTURE_BASE
    STORE32 BLT_DST_0, VRAM_START
    STORE32 BLT_WIDTH_LO, RENDER_W
    STORE32 BLT_HEIGHT_LO, RENDER_H
    STORE32 BLT_SRC_STRIDE_LO, 1024
    STORE32 BLT_DST_STRIDE_LO, LINE_BYTES
    STORE32 BLT_MODE7_TEX_W_0, 255
    STORE32 BLT_MODE7_TEX_H_0, 255

    ; Convert 24.8-ish coordinates/increments to signed 16.16 for Mode7:
    ; write (value << 8) into each 32-bit Mode7 register.
    ld hl,var_row_u
    ld de,BLT_MODE7_U0_0
    call write_mode7_shift8

    ld hl,var_row_v
    ld de,BLT_MODE7_V0_0
    call write_mode7_shift8

    ld hl,var_du_dx
    ld de,BLT_MODE7_DU_COL_0
    call write_mode7_shift8

    ld hl,var_dv_dx
    ld de,BLT_MODE7_DV_COL_0
    call write_mode7_shift8

    ld hl,var_du_dy
    ld de,BLT_MODE7_DU_ROW_0
    call write_mode7_shift8

    ld hl,var_dv_dy
    ld de,BLT_MODE7_DV_ROW_0
    call write_mode7_shift8

    START_BLIT
    WAIT_BLIT
    ret

; write_mode7_shift8
;   Input: HL = source 32-bit little-endian value, DE = destination register byte 0
;   Effect: writes (src << 8) as little-endian 32-bit to destination bytes [0..3].
write_mode7_shift8:
    xor a
    ld (de),a
    inc de

    ld a,(hl)
    ld (de),a
    inc hl
    inc de

    ld a,(hl)
    ld (de),a
    inc hl
    inc de

    ld a,(hl)
    ld (de),a
    ret

; Legacy CPU rasterizer path retained below (unused in main loop).
render_rotozoomer:
    SET_BANK3 TABLES_BANK_BASE
    xor a
    ld (var_curr_tex_bank),a

    ld hl,RENDER_H
    ld (var_row_count),hl
    ld hl,y_bank
    ld (var_y_bank_ptr),hl
    ld iy,y_off

.row_loop_render:
    ld hl,(var_y_bank_ptr)
    ld a,(hl)
    ld (VRAM_BANK_REG),a
    inc hl
    ld (var_y_bank_ptr),hl

    ld c,(iy+0)
    ld b,(iy+1)
    inc iy
    inc iy

    ld ix,VRAM_WINDOW
    add ix,bc

    ld hl,var_row_u
    ld de,var_u
    call copy32
    ld hl,var_row_v
    ld de,var_v
    call copy32

    ld b,40

.col_loop:
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL
    PIXEL

    ; Check if IX crossed bank boundary (>= 0xC000)
    push ix
    pop hl                          ; HL = current IX
    ld a,h
    cp 0xC0                         ; Compare high byte with 0xC0
    jr c,.no_bank_wrap              ; Jump if IX < 0xC000

    ; Crossed boundary - advance to next bank
    push af
    ld a,(VRAM_BANK_REG)
    inc a
    ld (VRAM_BANK_REG),a
    pop af

    ; Wrap IX back into window: IX -= 0x4000
    ld de,0x4000
    or a
    sbc hl,de
    push hl
    pop ix

.no_bank_wrap:

    dec b
    jp nz,.col_loop

    ld hl,var_row_u
    ld de,var_du_dy
    call add32
    ld hl,var_row_v
    ld de,var_dv_dy
    call add32

    ld hl,(var_row_count)
    dec hl
    ld (var_row_count),hl
    ld a,h
    or l
    jp nz,.row_loop_render

    ret

; =============================================================================
; BLIT BACK BUFFER TO FRONT
; =============================================================================
blit_to_front:
    SET_BLT_OP BLT_OP_COPY
    SET_BLT_SRC BACK_BUFFER
    SET_BLT_DST VRAM_START
    SET_BLT_WIDTH RENDER_W
    SET_BLT_HEIGHT RENDER_H
    SET_SRC_STRIDE LINE_BYTES
    SET_DST_STRIDE LINE_BYTES
    START_BLIT
    WAIT_BLIT
    ret

; =============================================================================
; 32-BIT HELPERS (little-endian)
; =============================================================================
load32:
    ld a,(hl)
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    ld (de),a
    ret

copy32:
    ld a,(hl)
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    ld (de),a
    ret

add32:
    ld a,(hl)
    ld c,a
    ld a,(de)
    add a,c
    ld (hl),a
    inc hl
    inc de
    ld a,(hl)
    ld c,a
    ld a,(de)
    adc a,c
    ld (hl),a
    inc hl
    inc de
    ld a,(hl)
    ld c,a
    ld a,(de)
    adc a,c
    ld (hl),a
    inc hl
    inc de
    ld a,(hl)
    ld c,a
    ld a,(de)
    adc a,c
    ld (hl),a
    ret

neg32:
    ld a,(hl)
    cpl
    add a,1
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    cpl
    adc a,0
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    cpl
    adc a,0
    ld (de),a
    inc hl
    inc de
    ld a,(hl)
    cpl
    adc a,0
    ld (de),a
    ret

; =============================================================================
; STATIC TABLES (small)
; =============================================================================
scale_bank_table:
    .byte TABLES_BANK_BASE
    .byte TABLES_BANK_BASE+1
    .byte TABLES_BANK_BASE+1
    .byte TABLES_BANK_BASE+2
    .byte TABLES_BANK_BASE+2

scale_off_table:
    .word OFF_SCALE0
    .word 0x0000
    .word 0x1000
    .word 0x0000
    .word 0x1000

; =============================================================================
; EMBEDDED DATA (precomputed)
; =============================================================================
    .org 0xE000
tables_blob:
    .incbin "rotozoomer_z80_tables.bin"
texture_blob:
    .incbin "rotozoomer_z80_texture.bin"
